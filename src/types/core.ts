/**
 * Core type definitions for the automation ecosystem
 * @module types/core
 */

/**
 * Environment configuration schema
 * All tokens are optional since we prefer CLI tools when available
 */
export interface EnvironmentConfig {
  /** GitHub personal access token (optional - uses gh CLI by default) */
  githubToken?: string;
  /** Gmail API OAuth token */
  gmailToken?: string;
  /** Buffer API access token */
  bufferToken?: string;
  /** Twitter API v2 bearer token */
  twitterToken?: string;
  /** OpenAI API key */
  openaiApiKey?: string;
}

/**
 * Base fossil interface for all fossil types
 */
export interface BaseFossil {
  type: string;
  source: string;
  createdBy: string;
  createdAt: string;
  fossilId?: string;
  fossilHash?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Context entry for fossil storage
 */
export interface ContextEntry {
  /** Unique identifier */
  id: string;
  /** Entry type */
  type: 'knowledge' | 'decision' | 'action' | 'observation' | 'plan' | 'result' | 'insight';
  /** Entry title */
  title: string;
  /** Entry content */
  content: string;
  /** Entry tags */
  tags: string[];
  /** Entry metadata */
  metadata: Record<string, unknown>;
  /** Entry source */
  source: 'llm' | 'terminal' | 'api' | 'manual' | 'automated';
  /** Entry version */
  version: number;
  /** Parent entry ID */
  parentId?: string;
  /** Child entry IDs */
  children: string[];
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
  /** Previous versions for version history */
  previousVersions?: Array<Omit<ContextEntry, 'previousVersions'>>;
  /** Semantic tags generated by LLM */
  semanticTags?: {
    /** Content hash for deduplication */
    contentHash: string;
    /** Duplicate group identifier */
    duplicateGroup?: string;
    /** Semantic category */
    semanticCategory?: string;
    /** Confidence score for auto-generated tags */
    confidence?: number;
    /** Whether tags were auto-generated */
    autoGenerated?: boolean;
    /** Extracted concepts */
    concepts?: string[];
    /** Sentiment analysis */
    sentiment?: 'positive' | 'negative' | 'neutral';
    /** Priority level */
    priority?: 'low' | 'medium' | 'high' | 'critical';
    /** Impact assessment */
    impact?: 'low' | 'medium' | 'high' | 'critical';
    /** Affected stakeholders */
    stakeholders?: string[];
    /** Similarity score for related content */
    similarityScore?: number;
  };
  /** Relationship tags */
  relationships?: {
    /** Related fossil IDs */
    relatedTo?: string[];
    /** Dependencies */
    dependsOn?: string[];
    /** Superseded fossils */
    supersedes?: string[];
    /** Part of larger project/initiative */
    partOf?: string[];
    /** Duplicate group members */
    duplicateGroup?: string[];
  };
  /** Temporal tags */
  temporal?: {
    /** Expiration date if applicable */
    expiresAt?: string;
    /** Lifecycle status */
    lifecycle?: 'active' | 'archived' | 'deprecated';
    /** Last accessed timestamp */
    lastAccessed?: string;
    /** Access frequency */
    accessCount?: number;
  };
  /** LLM-generated excerpt/summary for quick preview */
  excerpt?: string;
}

/**
 * Context query parameters
 */
export interface ContextQuery {
  /** Maximum number of entries to return */
  limit: number;
  /** Number of entries to skip */
  offset: number;
  /** Filter by entry type */
  type?: ContextEntry['type'];
  /** Filter by tags */
  tags?: string[];
  /** Filter by source */
  source?: ContextEntry['source'];
  /** Filter by date range */
  dateRange?: {
    start: string;
    end: string;
  };
  /** Search in title and content */
  search?: string;
}

/**
 * Generic service response wrapper
 */
export interface ServiceResponse<T> {
  /** Success status */
  success: boolean;
  /** Response data */
  data?: T;
  /** Error message */
  error?: string;
  /** HTTP status code */
  statusCode?: number;
}

/**
 * Common CLI options
 */
export interface CLIOptions {
  /** Repository owner (for GitHub operations) */
  owner?: string;
  /** Repository name (for GitHub operations) */
  repo?: string;
  /** Output format (json, text, table) */
  format?: 'json' | 'text' | 'table';
  /** Verbose output */
  verbose?: boolean;
  /** Dry run mode */
  dryRun?: boolean;
}

/**
 * Common status types
 */
export type Status = 'pending' | 'partial' | 'ready' | 'done' | 'open' | 'closed';
export type Priority = 'low' | 'medium' | 'high' | 'critical';
export type Impact = 'low' | 'medium' | 'high' | 'critical';

/**
 * Common fossil types
 */
export type FossilType = 
  | 'github_issue_fossil'
  | 'github_milestone_fossil'
  | 'github_label_fossil'
  | 'github_pr_fossil'
  | 'github_fossil_collection'
  | 'roadmap_fossil'
  | 'plan_fossil'
  | 'project_documentation_fossil';

export type FossilSource = 
  | 'roadmap-automation'
  | 'llm-human-collab'
  | 'automation'
  | 'manual'
  | 'api'
  | 'cli';

export type FossilCreator = 
  | 'automation'
  | 'llm'
  | 'human'
  | 'llm+human'
  | 'system';

/**
 * Fossil metadata interface
 */
export interface FossilMetadata {
  [key: string]: unknown;
}

/**
 * Fossil query interface
 */
export interface FossilQuery {
  type?: FossilType;
  source?: FossilSource;
  createdBy?: FossilCreator;
  search?: string;
  limit?: number;
  offset?: number;
  metadata?: Record<string, unknown>;
}

/**
 * Fossil result interface
 */
export interface FossilResult<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  fossilId?: string;
  fossilHash?: string;
}

/**
 * Fossil validation interface
 */
export interface FossilValidation {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Fossil collection interface
 */
export interface FossilCollection<T extends BaseFossil = BaseFossil> {
  type: 'fossil_collection';
  source: string;
  createdBy: string;
  createdAt: string;
  fossils: T[];
  metadata?: Record<string, unknown>;
} 