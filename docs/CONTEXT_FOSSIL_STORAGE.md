# 🗿 Context Fossil Storage

This document describes the Context Fossil Storage system - a self-documenting, persistent knowledge base that can be accessed and modified by LLMs, terminals, APIs, and future services. It serves as "fossil storage" for project knowledge, decisions, and insights.

## 🎯 Overview

The Context Fossil Storage system provides:

- **Persistent Knowledge Base**: Self-documenting storage that preserves project context
- **Multi-Source Input**: Accepts input from LLMs, terminals, APIs, and manual sources
- **Versioned Entries**: Tracks changes and maintains history of all entries
- **Relationship Mapping**: Links related entries through parent-child relationships
- **Flexible Querying**: Powerful search and filtering capabilities
- **Export Capabilities**: Multiple format exports for different use cases
- **LLM Integration**: Context summaries and insights for AI systems

## 🏗️ Architecture

### Core Components

1. **Fossil Storage Directory** (`.context-fossil/`)
   - `entries/` - Individual entry files (JSON)
   - `index.json` - Search index and metadata
   - `snapshots/` - Version snapshots
   - `exports/` - Export files

2. **Entry Types**
   - `knowledge` - General knowledge and information
   - `decision` - Project decisions and rationale
   - `action` - Actions taken and their outcomes
   - `observation` - Observations and insights
   - `plan` - Plans and strategies
   - `result` - Results and outcomes
   - `insight` - Key insights and learnings

3. **Sources**
   - `llm` - Generated by AI/LLM systems
   - `terminal` - Created via CLI commands
   - `api` - Added through API calls
   - `manual` - Manually created entries
   - `automated` - Automatically generated

### Data Structure

```json
{
  "id": "fossil_1234567890_abc123def",
  "type": "decision",
  "title": "Use Bun instead of Node.js",
  "content": "Decision to use Bun as the primary runtime...",
  "tags": ["technology", "performance", "decision"],
  "metadata": {
    "impact": "high",
    "stakeholders": ["team", "users"]
  },
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z",
  "source": "llm",
  "version": 1,
  "parentId": "fossil_1234567890_parent",
  "children": ["fossil_1234567890_child1", "fossil_1234567890_child2"]
}
```

## 🚀 Quick Start

### Initialize Fossil Storage

```bash
# Initialize the fossil storage system
bun run context:init
```

### Add Your First Entry

```bash
# Add a knowledge entry
bun run context:add \
  --type knowledge \
  --title "Project Architecture Decision" \
  --content "We chose to use Bun for its performance benefits..." \
  --tags "architecture,performance,decision" \
  --source manual
```

### Query Entries

```bash
# Find all decisions
bun run context:query --type decision

# Search for performance-related entries
bun run context:query --search "performance"

# Get entries with specific tags
bun run context:query --tags "architecture,decision"
```

## 📝 Entry Management

### Adding Entries

#### Via CLI
```bash
# Add a decision entry
bun run context:add \
  --type decision \
  --title "Database Choice" \
  --content "Selected PostgreSQL for ACID compliance..." \
  --tags "database,decision,architecture" \
  --source llm

# Add an action entry with parent relationship
bun run context:add \
  --type action \
  --title "Implemented Database Migration" \
  --content "Created migration scripts for PostgreSQL..." \
  --parent-id "fossil_1234567890_parent"
```

#### Via API (Future)
```javascript
// Example API call (future implementation)
const response = await fetch('/api/fossil/entries', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    type: 'knowledge',
    title: 'API Design Pattern',
    content: 'Using RESTful principles...',
    tags: ['api', 'design'],
    source: 'llm'
  })
});
```

### Updating Entries

```bash
# Update entry title and content
bun run context:update fossil_1234567890_abc123def \
  --title "Updated Database Decision" \
  --content "Revised decision based on new requirements..."

# Update tags
bun run context:update fossil_1234567890_abc123def \
  --tags "database,decision,architecture,postgresql"
```

### Querying Entries

#### Basic Queries
```bash
# Get all entries
bun run context:query

# Filter by type
bun run context:query --type insight

# Filter by source
bun run context:query --source llm

# Search in content
bun run context:query --search "database"
```

#### Advanced Queries
```bash
# Combine filters
bun run context:query \
  --type decision \
  --tags "architecture,performance" \
  --source llm \
  --limit 10

# Pagination
bun run context:query --limit 20 --offset 40
```

#### Output Formats
```bash
# JSON output
bun run context:query --format json

# Table output (default)
bun run context:query --format table
```

## 🔍 Search and Discovery

### Tag-Based Discovery
```bash
# Find all entries with architecture tag
bun run context:query --tags "architecture"

# Find entries with multiple tags
bun run context:query --tags "performance,decision"
```

### Content Search
```bash
# Search in titles and content
bun run context:query --search "database migration"

# Case-insensitive search
bun run context:query --search "POSTGRESQL"
```

### Relationship Discovery
```bash
# Get a specific entry
bun run context:get fossil_1234567890_abc123def

# Find related entries (future feature)
bun run context:related fossil_1234567890_abc123def
```

## 📊 Analytics and Insights

### Storage Statistics
```bash
# Get comprehensive statistics
bun run context:stats
```

Output:
```
📊 Fossil Storage Statistics

Total Entries: 156
Last Updated: 2024-01-15T10:30:00Z
Storage Size: 45.67 KB

By Type:
  knowledge: 45
  decision: 23
  action: 34
  observation: 28
  plan: 12
  result: 8
  insight: 6

By Source:
  llm: 67
  terminal: 34
  api: 12
  manual: 43

Top Tags:
  architecture: 23
  performance: 18
  decision: 15
  database: 12
  api: 10
```

### Context Summary for LLMs
```bash
# Generate context summary
bun run context:summary --limit 100
```

Output:
```json
{
  "totalEntries": 100,
  "byType": {
    "knowledge": 30,
    "decision": 15,
    "action": 25,
    "observation": 20,
    "insight": 10
  },
  "bySource": {
    "llm": 45,
    "terminal": 25,
    "manual": 30
  },
  "recentEntries": [
    {
      "id": "fossil_1234567890_recent1",
      "title": "Performance Optimization Decision",
      "type": "decision",
      "createdAt": "2024-01-15T10:30:00Z"
    }
  ],
  "keyInsights": [
    "Performance Optimization Decision: Chose Bun runtime for 3x faster startup times...",
    "Database Architecture: Selected PostgreSQL for ACID compliance and scalability..."
  ]
}
```

## 📤 Export and Integration

### Export Formats

#### JSON Export
```bash
# Export all entries as JSON
bun run context:export --format json

# Export filtered entries
bun run context:export --format json --type decision --tags "architecture"
```

#### Markdown Export
```bash
# Export as markdown documentation
bun run context:export --format markdown
```

Output:
```markdown
# Context Fossil Storage Export

Generated: 2024-01-15T10:30:00Z
Total Entries: 156

## Decision (23)

### Use Bun instead of Node.js

**ID:** fossil_1234567890_abc123def
**Created:** 2024-01-15T10:30:00Z
**Source:** llm
**Tags:** technology, performance, decision

Decision to use Bun as the primary runtime...

---
```

#### CSV Export
```bash
# Export as CSV for analysis
bun run context:export --format csv
```

#### YAML Export
```bash
# Export as YAML for configuration
bun run context:export --format yaml
```

### Integration with Other Systems

#### LLM Integration
```bash
# Get context summary for LLM prompts
bun run context:summary --type decision --tags "architecture" | \
  jq -r '.keyInsights[]' | \
  xargs -I {} echo "Context: {}"
```

#### API Integration (Future)
```javascript
// Example: Get context for API documentation
const context = await fetch('/api/fossil/summary?type=knowledge&tags=api')
  .then(res => res.json());

// Use context in API documentation generation
const apiDocs = generateApiDocs(context);
```

#### CI/CD Integration
```bash
# Export context before deployment
bun run context:export --format json --output pre-deployment-context.json

# Archive context after deployment
bun run context:add \
  --type result \
  --title "Deployment Completed" \
  --content "Successfully deployed version 1.2.0..." \
  --tags "deployment,success" \
  --source automated
```

## 🔄 Versioning and Snapshots

### Creating Snapshots
```bash
# Create a snapshot of current state
bun run context:snapshot --name "pre-major-refactor"

# Create milestone snapshot
bun run context:snapshot --name "v1.0-release"
```

### Restoring from Snapshots
```bash
# List available snapshots
bun run context:snapshots

# Restore from snapshot
bun run context:restore --snapshot-id fossil_1234567890_snapshot
```

## 🤖 LLM Integration Patterns

### Context Injection
```bash
# Get relevant context for LLM prompt
CONTEXT=$(bun run context:summary --type decision --tags "architecture" --format json)

# Use in LLM prompt
curl -X POST https://api.openai.com/v1/chat/completions \
  -H "Authorization: Bearer $OPENAI_API_KEY" \
  -H "Content-Type: application/json" \
  -d "{
    \"model\": \"gpt-4\",
    \"messages\": [
      {
        \"role\": \"system\",
        \"content\": \"Use this context: $CONTEXT\"
      },
      {
        \"role\": \"user\",
        \"content\": \"Analyze our architecture decisions\"
      }
    ]
  }"
```

### Automated Context Generation
```bash
# Add LLM-generated insights
bun run context:add \
  --type insight \
  --title "LLM Analysis: Performance Patterns" \
  --content "$(llm-analyze-performance)" \
  --tags "llm,analysis,performance" \
  --source llm
```

### Context-Aware Workflows
```bash
# Get context before making decisions
CONTEXT=$(bun run context:summary --type decision --tags "database")

# Use context in decision-making workflow
if echo "$CONTEXT" | grep -q "PostgreSQL"; then
  echo "PostgreSQL decision found in context"
  # Continue with PostgreSQL-related actions
fi
```

## 📋 Best Practices

### Entry Organization

#### Use Descriptive Titles
```bash
# Good
bun run context:add --title "Database Migration Strategy" --content "..."

# Avoid
bun run context:add --title "DB Stuff" --content "..."
```

#### Tag Consistently
```bash
# Use consistent tag patterns
--tags "technology,database,postgresql"
--tags "decision,architecture,performance"
--tags "action,implementation,migration"
```

#### Link Related Entries
```bash
# Create parent-child relationships
bun run context:add \
  --type plan \
  --title "Database Migration Plan" \
  --parent-id "fossil_1234567890_decision"

bun run context:add \
  --type action \
  --title "Execute Migration" \
  --parent-id "fossil_1234567890_plan"
```

### Content Quality

#### Write Clear Content
```bash
# Good content
--content "Selected PostgreSQL for its ACID compliance, 
extensive ecosystem, and proven reliability in production 
environments. This decision was based on our requirements 
for data consistency and scalability."

# Avoid vague content
--content "Chose PostgreSQL because it's good."
```

#### Include Rationale
```bash
# Include decision rationale
--content "Decision: Use Bun runtime
Rationale: 3x faster startup times, better memory usage
Alternatives considered: Node.js, Deno
Trade-offs: Smaller ecosystem but better performance"
```

### Maintenance

#### Regular Cleanup
```bash
# Archive old entries
bun run context:archive --older-than 90d

# Update outdated entries
bun run context:update fossil_old_entry --content "Updated information..."
```

#### Backup Strategy
```bash
# Create regular snapshots
bun run context:snapshot --name "weekly-backup-$(date +%Y-%m-%d)"

# Export to external storage
bun run context:export --format json --output "backup-$(date +%Y-%m-%d).json"
```

## 🔮 Future Enhancements

### Planned Features

#### Advanced Search
- Full-text search with relevance scoring
- Semantic search using embeddings
- Fuzzy matching for typos

#### Relationship Visualization
- Graph visualization of entry relationships
- Dependency mapping
- Impact analysis

#### AI-Powered Insights
- Automatic insight generation
- Trend analysis
- Anomaly detection

#### Real-time Collaboration
- Multi-user editing
- Conflict resolution
- Change tracking

#### API Ecosystem
- RESTful API for all operations
- Webhook notifications
- Third-party integrations

### Integration Roadmap

#### Q1 2024
- Basic fossil storage system
- CLI interface
- Export capabilities

#### Q2 2024
- API endpoints
- LLM integration patterns
- Advanced querying

#### Q3 2024
- Real-time collaboration
- AI-powered insights
- Visualization tools

#### Q4 2024
- Enterprise features
- Advanced analytics
- Ecosystem integrations

## 📚 Related Documentation

- [Repository Orchestrator](./REPOSITORY_ORCHESTRATOR.md) - Core orchestration system
- [Progress Tracking](./PROGRESS_TRACKING.md) - Monitoring and tracking
- [API Reference](./API_REFERENCE.md) - Technical API documentation
- [Development Guide](./DEVELOPMENT_GUIDE.md) - Development setup

## Prompt/System Message Fossilization

Curated prompts and system messages will be fossilized in `fossils/prompts/` and published as needed for LLM context, automation, and reproducibility. See [Fossil Publication Workflow](./FOSSIL_PUBLICATION_WORKFLOW.md) for the overall publication process and folder structure.

---

*The Context Fossil Storage system creates a living, breathing knowledge base that evolves with your project, preserving decisions, insights, and context for future reference and AI-powered analysis.* 